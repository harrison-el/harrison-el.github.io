<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Cutlist Optimizer</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.9/babel.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<style>
  *{box-sizing:border-box;margin:0;padding:0}
  body{font-family:system-ui,-apple-system,sans-serif;background:#F3F4F6}
  input,select,button{font-family:inherit}
  button{cursor:pointer;transition:opacity .15s}
  button:hover{opacity:.85}
  button:disabled{opacity:.4;cursor:default}
  select{appearance:auto}
  ::-webkit-scrollbar{width:6px}
  ::-webkit-scrollbar-thumb{background:#CBD5E1;border-radius:3px}
  @keyframes pulse{0%,100%{opacity:1}50%{opacity:.5}}
</style>
</head>
<body>
<div id="root"></div>
<script type="text/babel">
const { useState, useMemo, useRef, useCallback, useEffect } = React;

/* ═══ CONSTANTS ═══ */
const STOCK_TYPES = { "Beams": 290, "Louvers": 286, "Crown": 286, "Posts": 238, "Center Beams": 286 };
const MAT_COLORS = ["Black", "Bronze", "Stone", "White"];
const DAMAGE_TYPES = ["Dent", "Scratch", "Abrasion", "Powder Coat Imperfection", "Tolerance Issues"];
const MITER_WASTE = 4;
const PALETTE = ["#2563EB","#059669","#7C3AED","#D97706","#DB2777","#0891B2","#65A30D","#EA580C","#4F46E5","#0D9488","#DC2626","#9333EA","#0284C7","#C026D3","#06B6D4"];

/* ═══ UTILITIES ═══ */
function fmt(inches) {
  if (Math.abs(inches) < 0.001) return '0"';
  const s = inches < 0 ? "-" : "";
  const v = Math.round(Math.abs(inches) * 1000) / 1000;
  return s + (v === Math.floor(v) ? v : parseFloat(v.toFixed(3))) + '"';
}
function parseLen(str) {
  const s = (str || "").trim();
  if (!s) return NaN;
  let m = s.match(/^(\d+\.?\d*)\s*[']\s*(\d+\.?\d*)\s*["]?\s*$/);
  if (m) return parseFloat(m[1]) * 12 + parseFloat(m[2]);
  m = s.match(/^(\d+\.?\d*)\s*[']\s*$/);
  if (m) return parseFloat(m[1]) * 12;
  m = s.match(/^(\d+\.?\d*)\s*["]\s*$/);
  if (m) return parseFloat(m[1]);
  const n = parseFloat(s);
  return isNaN(n) ? NaN : n;
}
function colorFor(label) {
  const base = (label || "Cut").replace(/\s*#\d+$/, "");
  let h = 0;
  for (const ch of base) h = ((h << 5) - h + ch.charCodeAt(0)) | 0;
  return PALETTE[((h % PALETTE.length) + PALETTE.length) % PALETTE.length];
}
function cutLabel(c) { return c.label || "Cut #" + c.id; }
function fmtClock(seconds) {
  const m = Math.floor(seconds / 60), s = seconds % 60;
  return m + ":" + (s < 10 ? "0" : "") + s;
}
function fmtMin(minutes) {
  if (minutes < 1) return Math.round(minutes * 60) + " sec";
  return minutes.toFixed(1) + " min";
}
function tsStr(ts) {
  return new Date(ts).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
}

/* ═══ OPTIMIZATION ═══ */
function buildSegments(stock, damages) {
  const sorted = [...damages].sort((a, b) => a.start - b.start);
  const segs = []; let p = 0;
  for (const d of sorted) { if (d.start > p) segs.push({ start: p, len: d.start - p }); p = Math.max(p, d.end); }
  if (p < stock) segs.push({ start: p, len: stock - p });
  if (segs.length === 0 && damages.length === 0) segs.push({ start: 0, len: stock });
  return segs;
}
function placeCuts(cuts, segs, kerf, miterW, trackMiter) {
  const used = segs.map(() => 0), dirs = segs.map(() => null);
  const assigned = [], unassigned = []; let miterTotal = 0;
  for (const c of cuts) {
    let placed = false;
    for (let i = 0; i < segs.length; i++) {
      const k = used[i] > 0 ? kerf : 0;
      const mt = (trackMiter && dirs[i] && c.miterDir && dirs[i] !== c.miterDir) ? miterW : 0;
      if (c.length + k + mt <= segs[i].len - used[i] + 0.001) {
        assigned.push({ ...c, pos: segs[i].start + used[i] + k + mt, segIdx: i, kerfBefore: k > 0, miterBefore: mt > 0 });
        used[i] += c.length + k + mt;
        if (mt > 0) miterTotal += mt;
        if (c.miterDir) dirs[i] = c.miterDir;
        placed = true; break;
      }
    }
    if (!placed) unassigned.push(c);
  }
  return { assigned, unassigned, miterTotal };
}
function optimizeBeam(cuts, stock, kerf, damages = [], isCrown = false) {
  const cutOutDmg = damages.filter(d => !(d.consultCalled && d.consultResult === "Touch Up"));
  const segs = buildSegments(stock, cutOutDmg);
  let best;
  if (isCrown && cuts.some(c => c.miterDir)) {
    const L = cuts.filter(c => c.miterDir === "L").sort((a, b) => b.length - a.length);
    const R = cuts.filter(c => c.miterDir === "R").sort((a, b) => b.length - a.length);
    const N = cuts.filter(c => !c.miterDir).sort((a, b) => b.length - a.length);
    const r1 = placeCuts([...L, ...N, ...R], segs, kerf, MITER_WASTE, true);
    const r2 = placeCuts([...R, ...N, ...L], segs, kerf, MITER_WASTE, true);
    best = r1.assigned.length >= r2.assigned.length ? r1 : r2;
  } else {
    best = placeCuts([...cuts].sort((a, b) => b.length - a.length), segs, kerf, 0, false);
  }
  const cutTotal = best.assigned.reduce((s, a) => s + a.length, 0);
  const kerfTotal = best.assigned.reduce((s, a) => s + (a.kerfBefore ? kerf : 0), 0);
  const dmgTotal = cutOutDmg.reduce((s, d) => s + (d.end - d.start), 0);
  return {
    assigned: best.assigned, unassigned: best.unassigned,
    cutTotal, kerfTotal, dmgTotal, miterTotal: best.miterTotal || 0,
    waste: Math.max(0, stock - cutTotal - kerfTotal - dmgTotal - (best.miterTotal || 0)),
    efficiency: stock > 0 ? (cutTotal / stock) * 100 : 0,
  };
}
function estimateBeamCount(cuts, stock, kerf, isCrown) {
  let rem = [...cuts], count = 0, totalWaste = 0, totalCut = 0;
  while (rem.length > 0) {
    const r = optimizeBeam(rem, stock, kerf, [], isCrown);
    if (r.assigned.length === 0) break;
    count++; totalWaste += r.waste; totalCut += r.cutTotal; rem = r.unassigned;
  }
  return { count, totalWaste, totalCut, unplaceable: rem };
}

/* ═══ BEAM DIAGRAM ═══ */
function BeamDiagram({ stock, plan, damages = [], kerf = 0, damageMode, clickStart, onBeamClick, isCrown }) {
  const ref = useRef(null);
  const [hover, setHover] = useState(null);
  const pct = (v) => ((v / stock) * 100) + "%";
  const handleClick = useCallback((e) => {
    if (!damageMode || !ref.current) return;
    const rect = ref.current.getBoundingClientRect();
    onBeamClick && onBeamClick(Math.round(Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width)) * stock * 4) / 4);
  }, [damageMode, stock, onBeamClick]);
  const handleMove = useCallback((e) => {
    if (!ref.current) return;
    const rect = ref.current.getBoundingClientRect();
    setHover(Math.round(Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width)) * stock * 4) / 4);
  }, [stock]);
  const inchMarks = []; for (let i = 0; i <= stock; i += 24) inchMarks.push(i);
  return (
    <div style={{ position: "relative", marginBottom: 8 }}>
      <div ref={ref} onClick={handleClick} onMouseMove={handleMove} onMouseLeave={() => setHover(null)}
        style={{ position: "relative", height: 72, borderRadius: 6, backgroundColor: "#E5E7EB",
          border: damageMode ? "2px solid #EF4444" : "2px solid #9CA3AF",
          cursor: damageMode ? "crosshair" : "default", overflow: "hidden", boxShadow: "inset 0 2px 4px rgba(0,0,0,0.1)" }}>
        {plan && plan.assigned.map(c => (
          <div key={c.id} title={cutLabel(c) + ": " + fmt(c.length)} style={{
            position: "absolute", top: 4, height: 64, left: pct(c.pos), width: pct(c.length),
            backgroundColor: colorFor(cutLabel(c)), borderRadius: 3, display: "flex", alignItems: "center", justifyContent: "center",
            color: "#fff", fontSize: 11, fontWeight: 600, overflow: "hidden", whiteSpace: "nowrap", padding: "0 4px",
            boxShadow: "0 1px 3px rgba(0,0,0,0.2)" }}>
            <span style={{ textShadow: "0 1px 2px rgba(0,0,0,0.3)" }}>
              {c.length >= stock * 0.07 ? cutLabel(c) + " \u00B7 " + fmt(c.length) : ""}
            </span>
          </div>
        ))}
        {plan && plan.assigned.filter(c => c.kerfBefore).map(c => (
          <div key={"k-" + c.id} style={{ position: "absolute", top: 2, height: 68, left: pct(c.pos - kerf), width: Math.max(2, (kerf / stock) * 100) + "%", backgroundColor: "#111827", opacity: 0.7 }} />
        ))}
        {isCrown && plan && plan.assigned.filter(c => c.miterBefore).map(c => (
          <div key={"m-" + c.id} style={{ position: "absolute", top: 0, height: "100%", left: pct(c.pos - MITER_WASTE), width: pct(MITER_WASTE),
            backgroundColor: "rgba(251,191,36,0.5)", display: "flex", alignItems: "center", justifyContent: "center", fontSize: 9, color: "#92400E", fontWeight: 700 }}>
            {MITER_WASTE >= stock * 0.02 ? "MITER" : ""}
          </div>
        ))}
        {damages.map(d => {
          const isTU = d.consultCalled && d.consultResult === "Touch Up";
          return (
            <div key={d.id} style={{ position: "absolute", top: 0, height: "100%", left: pct(d.start), width: pct(d.end - d.start),
              backgroundColor: isTU ? "rgba(251,191,36,0.30)" : "rgba(239,68,68,0.35)",
              backgroundImage: isTU ? "repeating-linear-gradient(45deg,transparent,transparent 4px,rgba(251,191,36,0.35) 4px,rgba(251,191,36,0.35) 8px)" : "repeating-linear-gradient(45deg,transparent,transparent 4px,rgba(239,68,68,0.4) 4px,rgba(239,68,68,0.4) 8px)",
              borderLeft: "2px solid " + (isTU ? "#D97706" : "#DC2626"), borderRight: "2px solid " + (isTU ? "#D97706" : "#DC2626") }}>
              <span style={{ position: "absolute", top: "50%", left: "50%", transform: "translate(-50%,-50%)",
                color: isTU ? "#92400E" : "#991B1B", fontWeight: 700, fontSize: 10, textTransform: "uppercase", letterSpacing: 1, textShadow: "0 0 4px rgba(255,255,255,0.8)" }}>
                {(d.end - d.start) >= stock * 0.05 ? (isTU ? "TOUCH UP" : d.damageType || "DMG") : ""}
              </span>
            </div>
          );
        })}
        {damageMode && clickStart !== null && <div style={{ position: "absolute", top: 0, height: "100%", width: 3, left: pct(clickStart), backgroundColor: "#DC2626", zIndex: 10 }} />}
        {hover !== null && <div style={{ position: "absolute", top: -22, left: pct(hover), transform: "translateX(-50%)", backgroundColor: "#1F2937", color: "#fff", fontSize: 10, padding: "2px 6px", borderRadius: 4, whiteSpace: "nowrap", zIndex: 20, pointerEvents: "none" }}>{fmt(hover)}</div>}
      </div>
      <div style={{ position: "relative", height: 20, marginTop: 2 }}>
        {inchMarks.map(inc => <div key={inc} style={{ position: "absolute", left: pct(inc), transform: "translateX(-50%)", fontSize: 10, color: "#6B7280" }}><div style={{ width: 1, height: 6, backgroundColor: "#9CA3AF", margin: "0 auto 1px" }} />{inc}"</div>)}
      </div>
    </div>
  );
}

function Stat({ label, value, color }) {
  return (
    <div style={{ display: "inline-flex", flexDirection: "column", alignItems: "center", padding: "8px 14px", backgroundColor: color || "#F3F4F6", borderRadius: 8, minWidth: 85 }}>
      <span style={{ fontSize: 17, fontWeight: 700 }}>{value}</span>
      <span style={{ fontSize: 11, color: "#6B7280", marginTop: 2 }}>{label}</span>
    </div>
  );
}

/* ═══ XLSX EXPORTS ═══ */
function exportDamageReport(beams) {
  const rows = [];
  for (const b of beams) for (const d of b.damages) rows.push({
    "Beam #": b.id, "Bundle #": b.bundleNumber || "", "Stock Type": b.stockType, "Color": b.color,
    "Start (in)": d.start, "End (in)": d.end, "Length (in)": +(d.end - d.start).toFixed(3), "Length": fmt(d.end - d.start),
    "Damage Type": d.damageType, "Consult Called": d.consultCalled ? "Yes" : "No", "Consult Decision": d.consultCalled ? d.consultResult : "N/A",
  });
  if (!rows.length) rows.push({ "Note": "No damage recorded" });
  const ws = XLSX.utils.json_to_sheet(rows);
  ws["!cols"] = [{ wch: 8 },{ wch: 10 },{ wch: 14 },{ wch: 10 },{ wch: 10 },{ wch: 10 },{ wch: 12 },{ wch: 12 },{ wch: 26 },{ wch: 14 },{ wch: 16 }];
  const wb = XLSX.utils.book_new(); XLSX.utils.book_append_sheet(wb, ws, "Damage Report");
  XLSX.writeFile(wb, "damage-report-" + new Date().toISOString().slice(0, 10) + ".xlsx");
}

function exportDamageWaste(beams, stock) {
  const rows = [];
  for (const b of beams) {
    if (!b.damages.length) continue;
    const dmgTypes = [...new Set(b.damages.map(d => d.damageType))].join(", ");
    rows.push({
      "Beam #": b.id, "Bundle #": b.bundleNumber || "", "Stock Type": b.stockType, "Color": b.color,
      "Damage Zone Total (in)": +b.dmgTotal.toFixed(3), "Damage Zone Total": fmt(b.dmgTotal),
      "Inefficiency Waste (in)": +Math.max(0, (b.damageRelatedWaste || 0) - b.dmgTotal).toFixed(3),
      "Inefficiency Waste": fmt(Math.max(0, (b.damageRelatedWaste || 0) - b.dmgTotal)),
      "Total Damage-Derived Waste (in)": +(b.damageRelatedWaste || 0).toFixed(3),
      "Total Damage-Derived Waste": fmt(b.damageRelatedWaste || 0),
      "Damage Types": dmgTypes,
    });
  }
  if (!rows.length) rows.push({ "Note": "No damage waste recorded" });
  const ws = XLSX.utils.json_to_sheet(rows);
  ws["!cols"] = [{ wch: 8 },{ wch: 10 },{ wch: 14 },{ wch: 10 },{ wch: 20 },{ wch: 18 },{ wch: 20 },{ wch: 18 },{ wch: 26 },{ wch: 24 },{ wch: 30 }];
  const wb = XLSX.utils.book_new(); XLSX.utils.book_append_sheet(wb, ws, "Damage Waste");
  XLSX.writeFile(wb, "damage-waste-" + new Date().toISOString().slice(0, 10) + ".xlsx");
}

function exportShiftSummary(beams, cuts, stock, sessionStart, leadName, operatorName, matColor, stockType) {
  const totalParts = beams.reduce((s, b) => s + b.assigned.length, 0);
  const packCount = beams.reduce((s, b) => s + b.assigned.filter(c => c.disposition === "pack").length, 0);
  const tuCount = totalParts - packCount;
  const totalCut = beams.reduce((s, b) => s + b.cutTotal, 0);
  const totalDmgRelated = beams.reduce((s, b) => s + (b.damageRelatedWaste || 0), 0);
  const totalDmgZones = beams.reduce((s, b) => s + b.dmgTotal, 0);
  const totalStock = beams.length * stock;
  const eff = totalStock > 0 ? (totalCut / totalStock * 100) : 0;
  const adjEff = (totalStock - totalDmgZones) > 0 ? (totalCut / (totalStock - totalDmgZones) * 100) : 0;
  const endTime = beams.length > 0 ? beams[beams.length - 1].completedAt : Date.now();
  const taktArr = beams.map((b, i) => {
    const prev = i === 0 ? sessionStart : beams[i - 1].completedAt;
    return (b.completedAt - prev) / 1000 / 60 / b.assigned.length;
  });
  const avgTakt = taktArr.length > 0 ? taktArr.reduce((a, b) => a + b, 0) / taktArr.length : 0;

  const summary = [
    ["SHIFT SUMMARY REPORT"], [""],
    ["Lead", leadName || ""], ["Operator", operatorName || ""],
    ["Material", matColor + " " + stockType + " (" + fmt(stock) + ")"], [""],
    ["Session Start", new Date(sessionStart).toLocaleString()],
    ["Session End", new Date(endTime).toLocaleString()],
    ["Duration", fmtMin((endTime - sessionStart) / 1000 / 60)], [""],
    ["Total Beams", beams.length], ["Total Parts", totalParts],
    ["Pack", packCount], ["Touch Up", tuCount],
    ["Touch Up %", (totalParts > 0 ? (tuCount / totalParts * 100).toFixed(1) : "0") + "%"], [""],
    ["Overall Efficiency", eff.toFixed(1) + "%"],
    ["Adj. Efficiency (excl damage)", adjEff.toFixed(1) + "%"],
    ["Total Damage-Derived Waste", fmt(totalDmgRelated) + " (" + totalDmgRelated.toFixed(1) + ' in)'], [""],
    ["Avg Takt Time", fmtMin(avgTakt) + "/part"],
    ["Min Takt", taktArr.length > 0 ? fmtMin(Math.min(...taktArr)) + "/part" : "N/A"],
    ["Max Takt", taktArr.length > 0 ? fmtMin(Math.max(...taktArr)) + "/part" : "N/A"], [""],
    ["Recut Summary"], [""],
    ["Recuts", beams.reduce((s, b) => s + b.assigned.filter(c => c.recut).length, 0)],
    ["Avg Recut Takt", (() => { const rc = beams.flatMap(b => b.assigned).filter(c => c.recut && c.recutTakt); return rc.length > 0 ? fmtMin(rc.reduce((s, c) => s + c.recutTakt, 0) / rc.length) + "/recut" : "N/A"; })()],
    ["Total Recut Time", (() => { const rc = beams.flatMap(b => b.assigned).filter(c => c.recut && c.recutTakt); return rc.length > 0 ? fmtMin(rc.reduce((s, c) => s + c.recutTakt, 0)) : "N/A"; })()],
    ["Missed @ Saw (Pack\u2192TU)", beams.flatMap(b => b.assigned).filter(c => c.flippedToTU).length],
  ];
  const ws1 = XLSX.utils.aoa_to_sheet(summary);
  ws1["!cols"] = [{ wch: 30 }, { wch: 40 }];

  const detail = [];
  for (let i = 0; i < beams.length; i++) {
    const b = beams[i];
    const prev = i === 0 ? sessionStart : beams[i - 1].completedAt;
    const beamMin = (b.completedAt - prev) / 1000 / 60;
    const takt = beamMin / b.assigned.length;
    for (const c of [...b.assigned].sort((a, x) => a.pos - x.pos)) {
      detail.push({
        "Completed At": new Date(b.completedAt).toLocaleString(),
        "Beam #": b.id, "Bundle #": b.bundleNumber || "",
        "Cut": cutLabel(c), "Length (in)": c.length, "Length": fmt(c.length),
        "Position": fmt(c.pos) + " \u2192 " + fmt(c.pos + c.length),
        "Disposition": c.recut ? "Recut" : (c.disposition === "pack" ? "Pack" : "Touch Up"),
        "Beam Time (min)": +beamMin.toFixed(2),
        "Takt (min/part)": +takt.toFixed(2),
      });
      if (c.recut && c.recutNewLength) {
        detail.push({
          "Completed At": new Date(b.completedAt).toLocaleString(),
          "Beam #": b.id, "Bundle #": b.bundleNumber || "",
          "Cut": c.recutNewLabel || "Salvaged", "Length (in)": c.recutNewLength, "Length": fmt(c.recutNewLength),
          "Position": "Salvaged from " + cutLabel(c),
          "Disposition": "Salvaged",
          "Beam Time (min)": "",
          "Takt (min/part)": +(c.recutTakt || takt).toFixed(2),
        });
      }
    }
  }
  if (!detail.length) detail.push({ "Note": "No cuts completed" });
  const ws2 = XLSX.utils.json_to_sheet(detail);
  ws2["!cols"] = [{ wch: 20 },{ wch: 8 },{ wch: 10 },{ wch: 18 },{ wch: 12 },{ wch: 12 },{ wch: 22 },{ wch: 12 },{ wch: 14 },{ wch: 14 }];

  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, ws1, "Shift Summary");
  XLSX.utils.book_append_sheet(wb, ws2, "Cut Detail");
  XLSX.writeFile(wb, "shift-summary-" + new Date().toISOString().slice(0, 10) + ".xlsx");
}

/* ═══ MAIN ═══ */
function CutlistOptimizer() {
  const [matColor, setMatColor] = useState("Black");
  const [stockType, setStockType] = useState("Beams");
  const stock = STOCK_TYPES[stockType];
  const isCrown = stockType === "Crown";
  const [kerf, setKerf] = useState(0.125);
  const [kerfInput, setKerfInput] = useState("0.125");
  const [leadName, setLeadName] = useState("");
  const [operatorName, setOperatorName] = useState("");
  const [sheetsUrl, setSheetsUrl] = useState(() => { try { return localStorage.getItem("cutlist_sheets_url") || ""; } catch(e) { return ""; } });
  const [sheetsStatus, setSheetsStatus] = useState("");
  useEffect(() => { try { if (sheetsUrl) localStorage.setItem("cutlist_sheets_url", sheetsUrl); } catch(e) {} }, [sheetsUrl]);

  const [cuts, setCuts] = useState([]);
  const [nextId, setNextId] = useState(1);
  const [formLabel, setFormLabel] = useState("");
  const [formLen, setFormLen] = useState("");
  const [formQty, setFormQty] = useState(1);
  const [formMiter, setFormMiter] = useState("L");

  const [phase, setPhase] = useState("setup");
  const [completedBeams, setCompletedBeams] = useState([]);
  const [doneIds, setDoneIds] = useState(new Set());
  const [bundleNum, setBundleNum] = useState("");
  const [sessionStart, setSessionStart] = useState(null);

  const [currentDmg, setCurrentDmg] = useState([]);
  const [dmgMode, setDmgMode] = useState(false);
  const [dmgClickStart, setDmgClickStart] = useState(null);
  const [dmgStartIn, setDmgStartIn] = useState("");
  const [dmgEndIn, setDmgEndIn] = useState("");
  const [dmgType, setDmgType] = useState("Dent");
  const [dmgConsult, setDmgConsult] = useState(false);
  const [dmgConsultResult, setDmgConsultResult] = useState("Touch Up");
  const [dispositions, setDispositions] = useState({});

  const [adminClicks, setAdminClicks] = useState(0);
  const [showAdmin, setShowAdmin] = useState(false);
  const [resetConfirm, setResetConfirm] = useState(false);
  const adminTimeout = useRef(null);
  const [addCutOpen, setAddCutOpen] = useState(false);
  const [recutPanel, setRecutPanel] = useState(null);

  const [elapsed, setElapsed] = useState(0);
  useEffect(() => {
    if (phase !== "cutting") return;
    const base = completedBeams.length > 0 ? completedBeams[completedBeams.length - 1].completedAt : sessionStart;
    if (!base) return;
    const iv = setInterval(() => setElapsed(Math.floor((Date.now() - base) / 1000)), 1000);
    return () => clearInterval(iv);
  }, [phase, completedBeams.length, sessionStart]);

  const remaining = useMemo(() => cuts.filter(c => !doneIds.has(c.id)), [cuts, doneIds]);
  const currentPlan = useMemo(() => {
    if (phase !== "cutting" || remaining.length === 0) return null;
    return optimizeBeam(remaining, stock, kerf, currentDmg, isCrown);
  }, [remaining, stock, kerf, currentDmg, phase, isCrown]);
  const touchUpDmg = useMemo(() => currentDmg.filter(d => d.consultCalled && d.consultResult === "Touch Up"), [currentDmg]);
  const estimate = useMemo(() => cuts.length === 0 ? null : estimateBeamCount(cuts, stock, kerf, isCrown), [cuts, stock, kerf, isCrown]);

  /* ── Dashboard data ── */
  const dashData = useMemo(() => {
    if (completedBeams.length === 0) return null;
    const allCuts = completedBeams.flatMap(b => b.assigned);
    const tuCuts = allCuts.filter(c => c.disposition === "touchup").length;
    const tuPct = allCuts.length > 0 ? (tuCuts / allCuts.length * 100) : 0;
    const totalCut = completedBeams.reduce((s, b) => s + b.cutTotal, 0);
    const totalDmgZones = completedBeams.reduce((s, b) => s + b.dmgTotal, 0);
    const totalStock = completedBeams.length * stock;
    const adjEff = (totalStock - totalDmgZones) > 0 ? (totalCut / (totalStock - totalDmgZones) * 100) : 0;
    const taktArr = completedBeams.map((b, i) => {
      const prev = i === 0 ? sessionStart : completedBeams[i - 1].completedAt;
      const mins = (b.completedAt - prev) / 1000 / 60;
      return { beam: b.id, mins, parts: b.assigned.length, takt: mins / b.assigned.length, tuPct: b.assigned.length > 0 ? (b.assigned.filter(c => c.disposition === "touchup").length / b.assigned.length * 100) : 0 };
    });
    const avgTakt = taktArr.length > 0 ? taktArr.reduce((s, t) => s + t.takt, 0) / taktArr.length : 0;
    const maxTakt = taktArr.length > 0 ? Math.max(...taktArr.map(t => t.takt)) : 1;
    const recutCuts = allCuts.filter(c => c.recut && c.recutTakt);
    const recutCount = recutCuts.length;
    const totalRecutTime = recutCuts.reduce((s, c) => s + c.recutTakt, 0);
    const avgRecutTakt = recutCount > 0 ? totalRecutTime / recutCount : 0;
    const flippedCount = allCuts.filter(c => c.flippedToTU).length;
    return { tuPct, tuCuts, totalParts: allCuts.length, adjEff, taktArr, avgTakt, maxTakt, recutCount, avgRecutTakt, totalRecutTime, flippedCount };
  }, [completedBeams, sessionStart, stock]);

  function shouldAutoTouchUp(cut) { return touchUpDmg.some(d => cut.pos < d.end && (cut.pos + cut.length) > d.start); }

  function addCut() {
    const len = parseLen(formLen);
    if (isNaN(len) || len <= 0 || len > stock) return;
    const qty = Math.max(1, Math.min(200, formQty));
    const batch = [];
    for (let i = 0; i < qty; i++) {
      const l = formLabel.trim();
      batch.push({ id: nextId + i, label: l ? (qty > 1 ? l + " #" + (i + 1) : l) : "", length: len, miterDir: isCrown ? formMiter : null });
    }
    setCuts(p => [...p, ...batch]); setNextId(p => p + qty);
    setFormLabel(""); setFormLen(""); setFormQty(1);
  }
  function removeCut(id) { setCuts(p => p.filter(c => c.id !== id)); }

  function startCutting() {
    if (cuts.length === 0) return;
    setDoneIds(new Set()); setCompletedBeams([]);
    setCurrentDmg([]); setDmgMode(false); setDmgClickStart(null);
    setDispositions({}); setSessionStart(Date.now()); setPhase("cutting");
  }

  function addDamageFromForm() {
    const s = parseFloat(dmgStartIn), e = parseFloat(dmgEndIn);
    if (isNaN(s) || isNaN(e) || s >= e || s < 0 || e > stock) return;
    setCurrentDmg(p => [...p, { start: s, end: e, id: Date.now(), damageType: dmgType, consultCalled: dmgConsult, consultResult: dmgConsult ? dmgConsultResult : null }]);
    setDmgStartIn(""); setDmgEndIn("");
  }
  function handleBeamClick(pos) {
    if (dmgClickStart === null) { setDmgClickStart(pos); } else {
      const s = Math.min(dmgClickStart, pos), e = Math.max(dmgClickStart, pos);
      if (e - s > 0.1) setCurrentDmg(p => [...p, { start: s, end: e, id: Date.now(), damageType: dmgType, consultCalled: dmgConsult, consultResult: dmgConsult ? dmgConsultResult : null }]);
      setDmgClickStart(null);
    }
  }
  function removeDamage(id) { setCurrentDmg(p => p.filter(d => d.id !== id)); }
  function toggleDisposition(cutId) { setDispositions(p => ({ ...p, [cutId]: (p[cutId] || "pack") === "pack" ? "touchup" : "pack" })); }

  function completeBeam() {
    if (!currentPlan || currentPlan.assigned.length === 0) return;
    const now = Date.now();
    const assignedIds = new Set(currentPlan.assigned.map(c => c.id));
    const beamCuts = currentPlan.assigned.map(c => ({
      ...c, disposition: shouldAutoTouchUp(c) ? "touchup" : (dispositions[c.id] || "pack"),
    }));
    let damageRelatedWaste = 0;
    if (currentDmg.some(d => !(d.consultCalled && d.consultResult === "Touch Up"))) {
      const idealPlan = optimizeBeam(remaining, stock, kerf, [], isCrown);
      damageRelatedWaste = Math.max(0, (currentPlan.waste + currentPlan.dmgTotal) - idealPlan.waste);
    }
    setCompletedBeams(p => [...p, {
      id: p.length + 1, assigned: beamCuts, damages: [...currentDmg],
      waste: currentPlan.waste, kerfTotal: currentPlan.kerfTotal, dmgTotal: currentPlan.dmgTotal,
      miterTotal: currentPlan.miterTotal, efficiency: currentPlan.efficiency, cutTotal: currentPlan.cutTotal,
      bundleNumber: bundleNum, stockType, color: matColor, completedAt: now, damageRelatedWaste,
    }]);
    setDoneIds(prev => { const n = new Set(prev); for (const id of assignedIds) n.add(id); return n; });
    setCurrentDmg([]); setDmgMode(false); setDmgClickStart(null); setDispositions({});
    if (remaining.filter(c => !assignedIds.has(c.id)).length === 0) setPhase("done");
  }

  function handleAdminClick() {
    clearTimeout(adminTimeout.current);
    const n = adminClicks + 1; setAdminClicks(n);
    if (n >= 5) { setShowAdmin(true); setAdminClicks(0); return; }
    adminTimeout.current = setTimeout(() => setAdminClicks(0), 2000);
  }
  function confirmReset() { setPhase("setup"); setCompletedBeams([]); setDoneIds(new Set()); setCurrentDmg([]); setShowAdmin(false); setResetConfirm(false); setDispositions({}); }

  function undoLastBeam() {
    if (completedBeams.length === 0) return;
    const last = completedBeams[completedBeams.length - 1];
    const recutIds = new Set(last.assigned.filter(c => c.recutNewId).map(c => c.recutNewId));
    const customRecutIds = new Set(last.assigned.filter(c => c.recutNewId && c.recutIsCustom).map(c => c.recutNewId));
    if (customRecutIds.size > 0) setCuts(prev => prev.filter(c => !customRecutIds.has(c.id)));
    setCompletedBeams(prev => prev.slice(0, -1));
    setDoneIds(prev => { const n = new Set(prev); for (const c of last.assigned) n.delete(c.id); for (const id of recutIds) n.delete(id); return n; });
    setCurrentDmg(last.damages);
    const nd = {}; for (const c of last.assigned) nd[c.id] = c.disposition; setDispositions(nd);
    if (phase === "done") setPhase("cutting");
  }

  function flipCompletedDisp(bi, cid) {
    setCompletedBeams(prev => prev.map((b, i) => i !== bi ? b : { ...b, assigned: b.assigned.map(c => c.id !== cid ? c : { ...c, disposition: c.disposition === "pack" ? "touchup" : "pack", flippedToTU: c.disposition === "pack" ? true : c.flippedToTU }) }));
  }

  function openRecutPanel(bi, cid) {
    const beam = completedBeams[bi]; if (!beam) return;
    const cut = beam.assigned.find(c => c.id === cid); if (!cut || cut.recut) return;
    const preDmg = [];
    if (beam.damages) for (const d of beam.damages) {
      if (d.consultCalled && d.consultResult === "Touch Up") {
        const os = Math.max(d.start, cut.pos), oe = Math.min(d.end, cut.pos + cut.length);
        if (oe - os > 0.1) preDmg.push({ start: +(os - cut.pos).toFixed(2), end: +(oe - cut.pos).toFixed(2), id: Date.now() + Math.random(), damageType: d.damageType, fromBeam: true });
      }
    }
    setRecutPanel({ bi, cid, label: cutLabel(cut), stockLen: cut.length, damages: preDmg, selectedCutId: null, customLen: "", customLabel: "", useCustom: preDmg.length === 0 ? false : false, dmgStart: "", dmgEnd: "", dmgType: "Dent", recutStartedAt: Date.now() });
  }

  function confirmRecut() {
    if (!recutPanel) return;
    const { bi, cid, stockLen, damages, selectedCutId, customLen, customLabel, useCustom } = recutPanel;
    const rcSegs = buildSegments(stockLen, damages.map(d => ({ start: d.start, end: d.end })));
    const rcMax = rcSegs.length > 0 ? Math.max(...rcSegs.map(s => s.len)) : stockLen;
    const effectiveCustom = useCustom || remaining.filter(c => c.length <= rcMax - kerf).length === 0;
    let newLen, newLabel, newId, isCustom = false;
    if (effectiveCustom) {
      newLen = parseLen(customLen);
      if (isNaN(newLen) || newLen <= 0 || newLen > stockLen) return;
      newLabel = customLabel.trim() || "Recut Custom";
      newId = nextId; isCustom = true;
      setCuts(prev => [...prev, { id: newId, label: newLabel, length: newLen, miterDir: null }]);
      setNextId(prev => prev + 1);
    } else if (selectedCutId !== null) {
      const c = cuts.find(x => x.id === selectedCutId);
      if (!c) return;
      newLen = c.length; newLabel = cutLabel(c); newId = selectedCutId;
    } else return;
    setDoneIds(prev => { const n = new Set(prev); n.add(newId); return n; });
    const scrap = +(stockLen - newLen).toFixed(3);
    const recutTakt = recutPanel.recutStartedAt ? +((Date.now() - recutPanel.recutStartedAt) / 1000 / 60).toFixed(2) : 0;
    setCompletedBeams(prev => prev.map((b, i) => i !== bi ? b : {
      ...b, assigned: b.assigned.map(c => c.id !== cid ? c : {
        ...c, recut: true, recutNewId: newId, recutIsCustom: isCustom,
        recutDamages: damages, recutNewLength: newLen, recutNewLabel: newLabel, recutScrap: scrap, recutTakt
      })
    }));
    setRecutPanel(null);
    if (phase === "done") setPhase("cutting");
  }

  function logAllToSheets() {
    if (!sheetsUrl || sheetsStatus === "Sending...") return;
    const allC = completedBeams.flatMap(b => b.assigned);
    const tuCt = allC.filter(c => c.disposition === "touchup" && !c.recut).length;
    const pkCt = allC.filter(c => c.disposition === "pack" && !c.recut).length;
    const rcCt = allC.filter(c => c.recut).length;
    const totCut = completedBeams.reduce((s, b) => s + b.cutTotal, 0);
    const totDR = completedBeams.reduce((s, b) => s + (b.damageRelatedWaste || 0), 0);
    const totDZ = completedBeams.reduce((s, b) => s + b.dmgTotal, 0);
    const totStk = completedBeams.length * stock;
    const aEff = (totStk - totDZ) > 0 ? (totCut / (totStk - totDZ) * 100) : 0;
    const endT = completedBeams.length > 0 ? completedBeams[completedBeams.length - 1].completedAt : Date.now();
    const dur = sessionStart ? (endT - sessionStart) / 1000 / 60 : 0;
    const tArr = completedBeams.map((b, i) => { const p = i === 0 ? sessionStart : completedBeams[i - 1].completedAt; return (b.completedAt - p) / 1000 / 60 / b.assigned.length; });
    const avgT = tArr.length > 0 ? tArr.reduce((a, b) => a + b, 0) / tArr.length : 0;
    const recutsWithTakt = allC.filter(c => c.recut && c.recutTakt);
    const avgRecutT = recutsWithTakt.length > 0 ? +(recutsWithTakt.reduce((s, c) => s + c.recutTakt, 0) / recutsWithTakt.length).toFixed(2) : 0;
    const totalRecutT = recutsWithTakt.length > 0 ? +recutsWithTakt.reduce((s, c) => s + c.recutTakt, 0).toFixed(2) : 0;
    const flippedCt = allC.filter(c => c.flippedToTU).length;
    const shiftRow = [new Date().toLocaleDateString(), leadName || "", operatorName || "", matColor, stockType, stock, completedBeams.length, allC.length, pkCt, tuCt, rcCt, allC.length > 0 ? +(tuCt / allC.length * 100).toFixed(1) : 0, totStk > 0 ? +(totCut / totStk * 100).toFixed(1) : 0, +aEff.toFixed(1), +avgT.toFixed(2), +totDR.toFixed(1), +dur.toFixed(1), avgRecutT, totalRecutT, flippedCt];
    const dmgRows = [];
    for (const b of completedBeams) for (const d of b.damages) dmgRows.push([new Date().toLocaleDateString(), leadName || "", operatorName || "", matColor, stockType, b.id, b.bundleNumber || "", d.start, d.end, +(d.end - d.start).toFixed(1), d.damageType, d.consultCalled ? "Yes" : "No", d.consultCalled ? d.consultResult : "N/A"]);
    const cutRows = [];
    for (let i = 0; i < completedBeams.length; i++) { const b = completedBeams[i]; const pr = i === 0 ? sessionStart : completedBeams[i - 1].completedAt; const tk = (b.completedAt - pr) / 1000 / 60 / b.assigned.length; for (const c of b.assigned) { cutRows.push([new Date().toLocaleDateString(), leadName || "", operatorName || "", matColor, stockType, b.id, b.bundleNumber || "", cutLabel(c), c.length, c.recut ? "Recut" : (c.disposition === "pack" ? "Pack" : "Touch Up"), +tk.toFixed(2)]); if (c.recut && c.recutNewLength) cutRows.push([new Date().toLocaleDateString(), leadName || "", operatorName || "", matColor, stockType, b.id, b.bundleNumber || "", c.recutNewLabel || "Salvaged", c.recutNewLength, "Salvaged", +(c.recutTakt || tk).toFixed(2)]); } }
    const wasteRows = [];
    for (const b of completedBeams) {
      const recutScrap = b.assigned.filter(c => c.recut).reduce((s, c) => s + (c.recutScrap != null ? c.recutScrap : c.length), 0);
      if (b.damages.length === 0 && recutScrap === 0) continue;
      const dmgTypes = [...new Set(b.damages.map(d => d.damageType))].join(", ");
      const ineff = Math.max(0, (b.damageRelatedWaste || 0) - b.dmgTotal);
      const totalW = (b.damageRelatedWaste || 0) + recutScrap;
      wasteRows.push([new Date().toLocaleDateString(), leadName || "", operatorName || "", matColor, stockType, b.id, b.bundleNumber || "", +b.dmgTotal.toFixed(1), +ineff.toFixed(1), +(b.damageRelatedWaste || 0).toFixed(1), +recutScrap.toFixed(1), +totalW.toFixed(1), dmgTypes]);
    }
    setSheetsStatus("Sending...");
    fetch(sheetsUrl, { method: "POST", mode: "no-cors", headers: { "Content-Type": "text/plain;charset=utf-8" }, body: JSON.stringify({ shift: shiftRow, damages: dmgRows, cuts: cutRows, waste: wasteRows }) })
      .then(() => { setSheetsStatus("Sent!"); setTimeout(() => setSheetsStatus(""), 3000); })
      .catch(() => { setSheetsStatus("Error"); setTimeout(() => setSheetsStatus(""), 5000); });
  }

  const card = { backgroundColor: "#fff", borderRadius: 10, padding: 20, boxShadow: "0 1px 3px rgba(0,0,0,0.08)", border: "1px solid #E5E7EB", marginBottom: 16 };
  const btn = (bg, fg) => ({ padding: "8px 18px", borderRadius: 6, border: "none", backgroundColor: bg, color: fg || "#fff", fontWeight: 600, fontSize: 13 });
  const inp = { padding: "7px 10px", borderRadius: 6, border: "1px solid #D1D5DB", fontSize: 13, outline: "none", width: "100%", boxSizing: "border-box" };
  const sel = { ...inp, appearance: "auto", cursor: "pointer" };
  const lbl = { fontSize: 11, color: "#6B7280", fontWeight: 500, display: "block", marginBottom: 2 };

  return (
    <div style={{ minHeight: "100vh", backgroundColor: "#F3F4F6" }}>
      {/* HEADER */}
      <div onClick={phase === "cutting" ? handleAdminClick : undefined}
        style={{ background: "linear-gradient(135deg,#1E293B 0%,#334155 100%)", color: "#fff", padding: "16px 28px", marginBottom: 20, boxShadow: "0 2px 8px rgba(0,0,0,0.15)", userSelect: phase === "cutting" ? "none" : "auto" }}>
        <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", flexWrap: "wrap", gap: 8 }}>
          <div>
            <h1 style={{ margin: 0, fontSize: 22, fontWeight: 700, letterSpacing: -0.5 }}>Cutlist Optimizer</h1>
            <p style={{ margin: "3px 0 0", fontSize: 13, color: "#94A3B8" }}>
              {phase === "setup" && "Configure material, operators, and cuts"}
              {phase === "cutting" && matColor + " " + stockType + " \u2014 Beam " + (completedBeams.length + 1)}
              {phase === "done" && "Complete \u2014 " + completedBeams.length + " beam" + (completedBeams.length !== 1 ? "s" : "")}
            </p>
          </div>
          {phase === "cutting" && (
            <div style={{ textAlign: "right", fontSize: 12, color: "#94A3B8" }}>
              {leadName && <div><span style={{ color: "#64748B" }}>Lead:</span> {leadName}</div>}
              {operatorName && <div><span style={{ color: "#64748B" }}>Opr:</span> {operatorName}</div>}
            </div>
          )}
        </div>
      </div>

      {showAdmin && phase === "cutting" && (
        <div style={{ maxWidth: 960, margin: "0 auto 12px", padding: "0 16px" }}>
          <div style={{ backgroundColor: "#FEF2F2", border: "1px solid #FECACA", borderRadius: 8, padding: 12, display: "flex", alignItems: "center", gap: 10, justifyContent: "space-between", flexWrap: "wrap" }}>
            {!resetConfirm ? (
              <React.Fragment>
                <span style={{ fontSize: 13, color: "#991B1B" }}>Admin: Reset session?</span>
                <div style={{ display: "flex", gap: 6 }}>
                  <button style={btn("#DC2626")} onClick={() => setResetConfirm(true)}>Reset to Setup</button>
                  <button style={btn("#E5E7EB", "#374151")} onClick={() => setShowAdmin(false)}>Cancel</button>
                </div>
              </React.Fragment>
            ) : (
              <React.Fragment>
                <span style={{ fontSize: 13, color: "#991B1B", fontWeight: 600 }}>This will discard all progress. Are you sure?</span>
                <div style={{ display: "flex", gap: 6 }}>
                  <button style={btn("#DC2626")} onClick={confirmReset}>Yes, Reset</button>
                  <button style={btn("#E5E7EB", "#374151")} onClick={() => { setResetConfirm(false); setShowAdmin(false); }}>No</button>
                </div>
              </React.Fragment>
            )}
          </div>
        </div>
      )}

      <div style={{ maxWidth: 960, margin: "0 auto", padding: "0 16px 40px" }}>

        {/* ═══ SETUP ═══ */}
        {phase === "setup" && (
          <React.Fragment>
            {/* Operators */}
            <div style={card}>
              <h2 style={{ margin: "0 0 12px", fontSize: 15, fontWeight: 600, color: "#374151" }}>Operators</h2>
              <div style={{ display: "flex", gap: 14, flexWrap: "wrap" }}>
                <div style={{ flex: "1 1 180px" }}>
                  <label style={lbl}>Lead Name</label>
                  <input style={inp} value={leadName} onChange={e => setLeadName(e.target.value)} placeholder="Lead operator name" />
                </div>
                <div style={{ flex: "1 1 180px" }}>
                  <label style={lbl}>Operator Name</label>
                  <input style={inp} value={operatorName} onChange={e => setOperatorName(e.target.value)} placeholder="Second operator (optional)" />
                </div>
              </div>
            </div>
            {/* Google Sheets */}
            <div style={card}>
              <h2 style={{ margin: "0 0 12px", fontSize: 15, fontWeight: 600, color: "#374151" }}>Google Sheets (Optional)</h2>
              <div style={{ display: "flex", gap: 8, alignItems: "flex-end" }}>
                <div style={{ flex: "1 1 auto" }}>
                  <label style={lbl}>Apps Script Web App URL</label>
                  <input style={inp} value={sheetsUrl} onChange={e => setSheetsUrl(e.target.value)} placeholder="https://script.google.com/macros/s/..." />
                </div>
              </div>
              {sheetsUrl ? <p style={{ fontSize: 11, color: "#059669", marginTop: 6 }}>Connected &mdash; use "Log to Sheets" buttons after cuts are complete</p>
                : <p style={{ fontSize: 11, color: "#9CA3AF", marginTop: 6 }}>Paste your Apps Script URL to log shift data, damages, and cuts to Google Sheets</p>}
            </div>
            {/* Material */}
            <div style={card}>
              <h2 style={{ margin: "0 0 12px", fontSize: 15, fontWeight: 600, color: "#374151" }}>Material & Blade</h2>
              <div style={{ display: "flex", gap: 14, flexWrap: "wrap" }}>
                <div style={{ flex: "1 1 140px" }}><label style={lbl}>Color</label>
                  <select style={sel} value={matColor} onChange={e => setMatColor(e.target.value)}>{MAT_COLORS.map(c => <option key={c}>{c}</option>)}</select></div>
                <div style={{ flex: "1 1 170px" }}><label style={lbl}>Stock Type</label>
                  <select style={sel} value={stockType} onChange={e => setStockType(e.target.value)}>{Object.entries(STOCK_TYPES).map(([k, v]) => <option key={k} value={k}>{k} ({fmt(v)})</option>)}</select></div>
                <div style={{ flex: "0 0 110px" }}><label style={lbl}>Stock Length</label>
                  <input style={{ ...inp, backgroundColor: "#F3F4F6" }} value={fmt(stock)} readOnly /></div>
                <div style={{ flex: "0 0 130px" }}><label style={lbl}>Kerf / Blade (in)</label>
                  <input style={inp} value={kerfInput} onChange={e => { setKerfInput(e.target.value); const v = parseFloat(e.target.value); if (!isNaN(v) && v >= 0) setKerf(v); }} /></div>
              </div>
            </div>
            {/* Cut list */}
            <div style={card}>
              <h2 style={{ margin: "0 0 12px", fontSize: 15, fontWeight: 600, color: "#374151" }}>Cut List</h2>
              <div style={{ display: "flex", gap: 8, flexWrap: "wrap", marginBottom: 12, alignItems: "flex-end" }}>
                <div style={{ flex: "2 1 120px" }}><label style={lbl}>Name (optional)</label>
                  <input style={inp} value={formLabel} onChange={e => setFormLabel(e.target.value)} placeholder="e.g. Rafter" onKeyDown={e => e.key === "Enter" && addCut()} /></div>
                <div style={{ flex: "1 1 100px" }}><label style={lbl}>Length</label>
                  <input style={inp} value={formLen} onChange={e => setFormLen(e.target.value)} placeholder="inches or 8'6&quot;" onKeyDown={e => e.key === "Enter" && addCut()} /></div>
                <div style={{ flex: "0 0 55px" }}><label style={lbl}>Qty</label>
                  <input style={{ ...inp, textAlign: "center" }} type="number" min={1} max={200} value={formQty} onChange={e => setFormQty(parseInt(e.target.value) || 1)} onKeyDown={e => e.key === "Enter" && addCut()} /></div>
                {isCrown && <div style={{ flex: "0 0 80px" }}><label style={lbl}>Miter</label>
                  <select style={sel} value={formMiter} onChange={e => setFormMiter(e.target.value)}><option value="L">Left</option><option value="R">Right</option></select></div>}
                <button style={btn("#2563EB")} onClick={addCut}>+ Add</button>
              </div>
              {cuts.length === 0 ? <p style={{ color: "#9CA3AF", fontSize: 13, textAlign: "center", padding: 20 }}>No cuts added yet.</p> : (
                <div style={{ maxHeight: 300, overflowY: "auto" }}>
                  <table style={{ width: "100%", borderCollapse: "collapse", fontSize: 13 }}>
                    <thead><tr style={{ borderBottom: "2px solid #E5E7EB" }}>
                      <th style={{ textAlign: "left", padding: "6px 8px", color: "#6B7280", fontWeight: 500 }}>Cut</th>
                      <th style={{ textAlign: "right", padding: "6px 8px", color: "#6B7280", fontWeight: 500 }}>Length</th>
                      {isCrown && <th style={{ textAlign: "center", padding: "6px 8px", color: "#6B7280", fontWeight: 500 }}>Miter</th>}
                      <th style={{ width: 30 }}></th>
                    </tr></thead>
                    <tbody>{cuts.map(c => <tr key={c.id} style={{ borderBottom: "1px solid #F3F4F6" }}>
                      <td style={{ padding: "6px 8px" }}><span style={{ display: "inline-block", width: 10, height: 10, borderRadius: 2, backgroundColor: colorFor(cutLabel(c)), marginRight: 8, verticalAlign: "middle" }} />{cutLabel(c)}</td>
                      <td style={{ textAlign: "right", padding: "6px 8px", fontFamily: "monospace" }}>{fmt(c.length)}</td>
                      {isCrown && <td style={{ textAlign: "center", padding: "6px 8px" }}>{c.miterDir === "L" ? "Left" : "Right"}</td>}
                      <td><button onClick={() => removeCut(c.id)} style={{ border: "none", background: "none", color: "#EF4444", cursor: "pointer", fontSize: 16 }}>&times;</button></td>
                    </tr>)}</tbody>
                  </table>
                </div>
              )}
            </div>
            {estimate && cuts.length > 0 && (
              <div style={card}>
                <h2 style={{ margin: "0 0 12px", fontSize: 15, fontWeight: 600, color: "#374151" }}>Estimated Plan</h2>
                <div style={{ display: "flex", gap: 12, flexWrap: "wrap", marginBottom: 16 }}>
                  <Stat label="Beams" value={estimate.count} color="#DBEAFE" />
                  <Stat label="Total Cut" value={fmt(estimate.totalCut)} color="#D1FAE5" />
                  <Stat label="Waste" value={fmt(estimate.totalWaste)} color="#FEF3C7" />
                  <Stat label="Efficiency" value={((estimate.totalCut / (estimate.count * stock)) * 100).toFixed(1) + "%"} color="#E0E7FF" />
                </div>
                {estimate.unplaceable.length > 0 && <p style={{ color: "#DC2626", fontSize: 13 }}>{estimate.unplaceable.length} cut(s) exceed stock length.</p>}
                <button style={{ ...btn("#059669"), marginTop: 8, padding: "10px 28px", fontSize: 14 }} onClick={startCutting}>Begin Cutting</button>
              </div>
            )}
          </React.Fragment>
        )}

        {/* ═══ CUTTING ═══ */}
        {phase === "cutting" && currentPlan && (
          <React.Fragment>
            <div style={card}>
              <div style={{ display: "flex", gap: 14, flexWrap: "wrap", alignItems: "flex-end" }}>
                <div style={{ flex: "0 0 150px" }}><label style={lbl}>Bundle #</label>
                  <input style={inp} value={bundleNum} onChange={e => setBundleNum(e.target.value)} placeholder="Bundle #" /></div>
                <div style={{ fontSize: 13, color: "#6B7280", paddingBottom: 8, display: "flex", gap: 14, flexWrap: "wrap" }}>
                  <span><strong>{matColor}</strong> {stockType}</span>
                  <span>Stock: {fmt(stock)}</span>
                  <span>Kerf: {kerf}"</span>
                </div>
              </div>
            </div>

            {/* Add Cut Mid-Program */}
            <div style={card}>
              <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center" }}>
                <h2 style={{ margin: 0, fontSize: 15, fontWeight: 600, color: "#374151" }}>Add Cut to Queue</h2>
                <button style={btn(addCutOpen ? "#6B7280" : "#2563EB")} onClick={() => setAddCutOpen(!addCutOpen)}>{addCutOpen ? "Close" : "+ Add Cut"}</button>
              </div>
              {addCutOpen && (
                <div style={{ marginTop: 12, display: "flex", gap: 8, flexWrap: "wrap", alignItems: "flex-end" }}>
                  <div style={{ flex: "2 1 120px" }}><label style={lbl}>Name (optional)</label>
                    <input style={inp} value={formLabel} onChange={e => setFormLabel(e.target.value)} placeholder="e.g. Hot Item" onKeyDown={e => e.key === "Enter" && addCut()} /></div>
                  <div style={{ flex: "1 1 90px" }}><label style={lbl}>Length</label>
                    <input style={inp} value={formLen} onChange={e => setFormLen(e.target.value)} placeholder="inches" onKeyDown={e => e.key === "Enter" && addCut()} /></div>
                  <div style={{ flex: "0 0 55px" }}><label style={lbl}>Qty</label>
                    <input style={{ ...inp, textAlign: "center" }} type="number" min={1} max={200} value={formQty} onChange={e => setFormQty(parseInt(e.target.value) || 1)} onKeyDown={e => e.key === "Enter" && addCut()} /></div>
                  {isCrown && <div style={{ flex: "0 0 80px" }}><label style={lbl}>Miter</label>
                    <select style={sel} value={formMiter} onChange={e => setFormMiter(e.target.value)}><option value="L">Left</option><option value="R">Right</option></select></div>}
                  <button style={btn("#2563EB")} onClick={() => { addCut(); }}>+ Add</button>
                </div>
              )}
            </div>

            {/* Beam */}
            <div style={card}>
              <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 12, flexWrap: "wrap", gap: 6 }}>
                <h2 style={{ margin: 0, fontSize: 15, fontWeight: 600, color: "#374151" }}>Beam {completedBeams.length + 1}</h2>
                <div style={{ display: "flex", gap: 12, alignItems: "center" }}>
                  <span style={{ fontSize: 12, color: "#6B7280" }}>{remaining.length} in queue</span>
                  <span style={{ fontSize: 13, fontFamily: "monospace", color: "#2563EB", fontWeight: 600, animation: "pulse 2s infinite" }}>{fmtClock(elapsed)}</span>
                </div>
              </div>
              <BeamDiagram stock={stock} plan={currentPlan} damages={currentDmg} kerf={kerf} damageMode={dmgMode} clickStart={dmgClickStart} onBeamClick={handleBeamClick} isCrown={isCrown} />
              <div style={{ display: "flex", gap: 10, flexWrap: "wrap", marginTop: 12 }}>
                <Stat label="Cuts" value={currentPlan.assigned.length} color="#DBEAFE" />
                <Stat label="Used" value={fmt(currentPlan.cutTotal)} color="#D1FAE5" />
                <Stat label="Kerf" value={fmt(currentPlan.kerfTotal)} color="#FEE2E2" />
                <Stat label="Waste" value={fmt(currentPlan.waste)} color="#FEF3C7" />
                {currentPlan.dmgTotal > 0 && <Stat label="Damage" value={fmt(currentPlan.dmgTotal)} color="#FECACA" />}
                {currentPlan.miterTotal > 0 && <Stat label="Miter" value={fmt(currentPlan.miterTotal)} color="#FDE68A" />}
                <Stat label="Eff" value={currentPlan.efficiency.toFixed(1) + "%"} color="#E0E7FF" />
              </div>
            </div>

            {/* Dashboard */}
            {dashData && (
              <div style={{ ...card, background: "linear-gradient(135deg,#F8FAFC,#EFF6FF)", borderColor: "#BFDBFE" }}>
                <h2 style={{ margin: "0 0 12px", fontSize: 15, fontWeight: 600, color: "#1E40AF" }}>Shift Dashboard</h2>
                <div style={{ display: "flex", gap: 12, flexWrap: "wrap", marginBottom: 14 }}>
                  <Stat label="Touch Up %" value={dashData.tuPct.toFixed(1) + "%"} color={dashData.tuPct > 20 ? "#FEE2E2" : dashData.tuPct > 10 ? "#FEF3C7" : "#D1FAE5"} />
                  <Stat label="Avg Takt" value={fmtMin(dashData.avgTakt)} color="#DBEAFE" />
                  {dashData.recutCount > 0 && <Stat label="Recut Takt" value={fmtMin(dashData.avgRecutTakt)} color="#F3E8FF" />}
                  <Stat label="Adj Efficiency" value={dashData.adjEff.toFixed(1) + "%"} color="#E0E7FF" />
                  <Stat label="Parts Done" value={dashData.totalParts} color="#F3F4F6" />
                  {dashData.flippedCount > 0 && <Stat label="Missed @ Saw" value={dashData.flippedCount} color="#FEE2E2" />}
                </div>
                <div style={{ display: "flex", alignItems: "center", gap: 8, marginBottom: 10 }}>
                  <span style={{ fontSize: 11, color: "#6B7280", width: 50 }}>T/U Rate</span>
                  <div style={{ flex: 1, height: 8, backgroundColor: "#E5E7EB", borderRadius: 4, overflow: "hidden" }}>
                    <div style={{ height: "100%", width: Math.min(100, dashData.tuPct) + "%", borderRadius: 4, backgroundColor: dashData.tuPct > 20 ? "#EF4444" : dashData.tuPct > 10 ? "#F59E0B" : "#059669", transition: "width 0.3s" }} />
                  </div>
                  <span style={{ fontSize: 11, color: "#6B7280", width: 70, textAlign: "right" }}>{dashData.tuCuts}/{dashData.totalParts}</span>
                </div>
                <div style={{ fontSize: 12, color: "#374151", fontWeight: 600, marginBottom: 6 }}>Takt Time per Beam</div>
                {dashData.taktArr.map(t => (
                  <div key={t.beam} style={{ display: "flex", alignItems: "center", gap: 8, marginBottom: 3 }}>
                    <span style={{ width: 52, fontSize: 11, color: "#6B7280" }}>Beam {t.beam}</span>
                    <div style={{ flex: 1, height: 18, backgroundColor: "#E5E7EB", borderRadius: 4, overflow: "hidden" }}>
                      <div style={{ height: "100%", width: Math.min(100, (t.takt / dashData.maxTakt) * 100) + "%", borderRadius: 4,
                        backgroundColor: t.takt > dashData.avgTakt * 1.5 ? "#EF4444" : "#3B82F6",
                        display: "flex", alignItems: "center", paddingLeft: 6, fontSize: 10, color: "#fff", fontWeight: 600, minWidth: 40 }}>
                        {fmtMin(t.takt)}
                      </div>
                    </div>
                    <span style={{ fontSize: 10, color: "#9CA3AF", width: 80, textAlign: "right" }}>{t.parts} parts &middot; {t.tuPct.toFixed(0)}% TU</span>
                  </div>
                ))}
              </div>
            )}

            {/* Cuts with disposition */}
            <div style={card}>
              <h2 style={{ margin: "0 0 10px", fontSize: 15, fontWeight: 600, color: "#374151" }}>Cuts ({currentPlan.assigned.length})</h2>
              {currentPlan.assigned.length === 0 ? <p style={{ color: "#EF4444", fontSize: 13 }}>No cuts fit. Complete beam to continue.</p> : (
                <table style={{ width: "100%", borderCollapse: "collapse", fontSize: 13 }}>
                  <thead><tr style={{ borderBottom: "2px solid #E5E7EB" }}>
                    <th style={{ textAlign: "left", padding: "5px 8px", color: "#6B7280", fontWeight: 500 }}>Cut</th>
                    <th style={{ textAlign: "right", padding: "5px 8px", color: "#6B7280", fontWeight: 500 }}>Length</th>
                    <th style={{ textAlign: "right", padding: "5px 8px", color: "#6B7280", fontWeight: 500 }}>Position</th>
                    {isCrown && <th style={{ textAlign: "center", padding: "5px 8px", color: "#6B7280", fontWeight: 500 }}>Miter</th>}
                    <th style={{ textAlign: "center", padding: "5px 8px", color: "#6B7280", fontWeight: 500 }}>Disposition</th>
                  </tr></thead>
                  <tbody>{[...currentPlan.assigned].sort((a, b) => a.pos - b.pos).map(c => {
                    const auto = shouldAutoTouchUp(c);
                    const disp = auto ? "touchup" : (dispositions[c.id] || "pack");
                    return <tr key={c.id} style={{ borderBottom: "1px solid #F3F4F6", backgroundColor: disp === "touchup" ? "#FFFBEB" : "transparent" }}>
                      <td style={{ padding: "5px 8px" }}><span style={{ display: "inline-block", width: 10, height: 10, borderRadius: 2, backgroundColor: colorFor(cutLabel(c)), marginRight: 8 }} />{cutLabel(c)}</td>
                      <td style={{ textAlign: "right", padding: "5px 8px", fontFamily: "monospace" }}>{fmt(c.length)}</td>
                      <td style={{ textAlign: "right", padding: "5px 8px", fontFamily: "monospace", color: "#6B7280" }}>{fmt(c.pos)} &rarr; {fmt(c.pos + c.length)}</td>
                      {isCrown && <td style={{ textAlign: "center", padding: "5px 8px" }}>{c.miterDir === "L" ? "L" : c.miterDir === "R" ? "R" : "\u2014"}</td>}
                      <td style={{ textAlign: "center", padding: "5px 4px" }}>
                        {auto ? <span style={{ fontSize: 11, color: "#D97706", fontWeight: 600, padding: "3px 10px", backgroundColor: "#FEF3C7", borderRadius: 4 }}>Touch Up (auto)</span>
                          : <button onClick={() => toggleDisposition(c.id)} style={{ ...btn(disp === "pack" ? "#059669" : "#D97706"), fontSize: 11, padding: "3px 10px" }}>{disp === "pack" ? "Pack" : "Touch Up"}</button>}
                      </td>
                    </tr>;
                  })}</tbody>
                </table>
              )}
            </div>

            {/* Damage */}
            <div style={{ ...card, borderColor: dmgMode ? "#FCA5A5" : "#E5E7EB" }}>
              <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 10 }}>
                <h2 style={{ margin: 0, fontSize: 15, fontWeight: 600, color: dmgMode ? "#DC2626" : "#374151" }}>Report Damage</h2>
                <button style={btn(dmgMode ? "#6B7280" : "#EF4444")} onClick={() => { setDmgMode(!dmgMode); setDmgClickStart(null); }}>{dmgMode ? "Exit Damage Mode" : "Enter Damage Mode"}</button>
              </div>
              {dmgMode && (
                <div style={{ marginBottom: 10 }}>
                  <p style={{ fontSize: 12, color: "#6B7280", margin: "0 0 8px" }}>Click two points on the beam, or enter positions:</p>
                  {dmgClickStart !== null && <p style={{ fontSize: 12, color: "#DC2626", margin: "0 0 8px" }}>Start: {fmt(dmgClickStart)} &mdash; click again for end.</p>}
                  <div style={{ display: "flex", gap: 8, flexWrap: "wrap", alignItems: "flex-end", marginBottom: 8 }}>
                    <div style={{ flex: "0 0 85px" }}><label style={lbl}>Start (in)</label><input style={inp} value={dmgStartIn} onChange={e => setDmgStartIn(e.target.value)} placeholder="48" /></div>
                    <div style={{ flex: "0 0 85px" }}><label style={lbl}>End (in)</label><input style={inp} value={dmgEndIn} onChange={e => setDmgEndIn(e.target.value)} placeholder="72" onKeyDown={e => e.key === "Enter" && addDamageFromForm()} /></div>
                    <div style={{ flex: "1 1 160px" }}><label style={lbl}>Damage Type</label><select style={sel} value={dmgType} onChange={e => setDmgType(e.target.value)}>{DAMAGE_TYPES.map(t => <option key={t}>{t}</option>)}</select></div>
                  </div>
                  <div style={{ display: "flex", gap: 8, flexWrap: "wrap", alignItems: "flex-end" }}>
                    <div style={{ flex: "0 0 130px" }}><label style={lbl}>Consult Called?</label><select style={sel} value={dmgConsult ? "yes" : "no"} onChange={e => setDmgConsult(e.target.value === "yes")}><option value="no">No</option><option value="yes">Yes</option></select></div>
                    {dmgConsult && <div style={{ flex: "0 0 150px" }}><label style={lbl}>Decision</label><select style={sel} value={dmgConsultResult} onChange={e => setDmgConsultResult(e.target.value)}><option value="Touch Up">Touch Up</option><option value="Cut Out">Cut Out</option></select></div>}
                    <button style={btn("#DC2626")} onClick={addDamageFromForm}>Mark Damage</button>
                  </div>
                </div>
              )}
              {currentDmg.length > 0 && (
                <div style={{ marginTop: 8 }}>
                  {currentDmg.map(d => {
                    const isTU = d.consultCalled && d.consultResult === "Touch Up";
                    return <div key={d.id} style={{ display: "flex", alignItems: "center", gap: 8, flexWrap: "wrap", backgroundColor: isTU ? "#FFFBEB" : "#FEF2F2", border: "1px solid " + (isTU ? "#FDE68A" : "#FECACA"), borderRadius: 6, padding: "5px 10px", marginBottom: 4, fontSize: 12 }}>
                      <span style={{ fontWeight: 600, color: isTU ? "#92400E" : "#991B1B" }}>{fmt(d.start)} &rarr; {fmt(d.end)} ({fmt(d.end - d.start)})</span>
                      <span style={{ color: "#6B7280" }}>{d.damageType}</span>
                      {d.consultCalled && <span style={{ color: isTU ? "#D97706" : "#DC2626", fontWeight: 600, fontSize: 11, padding: "1px 6px", borderRadius: 3, backgroundColor: isTU ? "#FEF3C7" : "#FEE2E2" }}>{d.consultResult}</span>}
                      {!d.consultCalled && <span style={{ color: "#9CA3AF", fontSize: 11 }}>No consult</span>}
                      <button onClick={() => removeDamage(d.id)} style={{ border: "none", background: "none", color: "#EF4444", cursor: "pointer", fontSize: 14, fontWeight: 700, marginLeft: "auto" }}>&times;</button>
                    </div>;
                  })}
                </div>
              )}
              {currentDmg.length > 0 && currentPlan.unassigned.length > 0 && (
                <p style={{ fontSize: 12, color: "#D97706", marginTop: 8, backgroundColor: "#FFFBEB", padding: "6px 10px", borderRadius: 6 }}>
                  {currentPlan.unassigned.length} cut{currentPlan.unassigned.length !== 1 ? "s" : ""} moved to queue.
                </p>
              )}
            </div>

            {/* Actions */}
            <div style={{ display: "flex", gap: 10, marginBottom: 16, flexWrap: "wrap", alignItems: "center" }}>
              <button style={{ ...btn("#059669"), padding: "10px 28px", fontSize: 14 }} onClick={completeBeam} disabled={currentPlan.assigned.length === 0}>Complete Beam &rarr;</button>
              {completedBeams.length > 0 && <button style={{ ...btn("#E5E7EB", "#6B7280"), padding: "6px 12px", fontSize: 11 }} onClick={undoLastBeam} title="Undo last completed beam">&larr; Undo Last</button>}
              {completedBeams.length > 0 && (
                <React.Fragment>
                  <button style={btn("#4F46E5")} onClick={() => exportDamageReport(completedBeams)}>Damage Report</button>
                  <button style={btn("#7C3AED")} onClick={() => exportDamageWaste(completedBeams, stock)}>Damage Waste</button>
                  <button style={btn("#0891B2")} onClick={() => exportShiftSummary(completedBeams, cuts, stock, sessionStart, leadName, operatorName, matColor, stockType)}>Shift Summary</button>
                  {sheetsUrl && <button style={{ ...btn("#059669"), fontSize: 12 }} onClick={logAllToSheets} disabled={sheetsStatus === "Sending..."}>{sheetsStatus || "Log to Sheets"}</button>}
                </React.Fragment>
              )}
            </div>

            {currentPlan.unassigned.length > 0 && (
              <div style={card}>
                <h2 style={{ margin: "0 0 10px", fontSize: 15, fontWeight: 600, color: "#374151" }}>Queue ({currentPlan.unassigned.length})</h2>
                <div style={{ maxHeight: 180, overflowY: "auto" }}>
                  {currentPlan.unassigned.map(c => <div key={c.id} style={{ display: "flex", justifyContent: "space-between", padding: "5px 8px", borderBottom: "1px solid #F3F4F6", fontSize: 13 }}>
                    <span><span style={{ display: "inline-block", width: 8, height: 8, borderRadius: 2, backgroundColor: colorFor(cutLabel(c)), marginRight: 6 }} />{cutLabel(c)}</span>
                    <span style={{ fontFamily: "monospace", color: "#6B7280" }}>{fmt(c.length)}</span>
                  </div>)}
                </div>
              </div>
            )}

            {completedBeams.length > 0 && (
              <div style={card}>
                <h2 style={{ margin: "0 0 10px", fontSize: 15, fontWeight: 600, color: "#374151" }}>Completed ({completedBeams.length})</h2>
                {completedBeams.map((b, bIdx) => (
                  <div key={b.id} style={{ marginBottom: 10, padding: 10, backgroundColor: "#F9FAFB", borderRadius: 6, border: "1px solid #E5E7EB" }}>
                    <div style={{ fontSize: 13, fontWeight: 600, marginBottom: 6 }}>Beam {b.id}{b.bundleNumber ? " \u2014 Bndl " + b.bundleNumber : ""} <span style={{ fontWeight: 400, color: "#9CA3AF", fontSize: 11 }}>@ {tsStr(b.completedAt)}</span></div>
                    <BeamDiagram stock={stock} plan={{ assigned: b.assigned }} damages={b.damages} kerf={kerf} isCrown={isCrown} />
                    <div style={{ display: "flex", gap: 8, fontSize: 11, color: "#6B7280", flexWrap: "wrap", marginBottom: 6 }}>
                      <span>{b.assigned.length} cuts</span><span>&middot;</span><span>{fmt(b.cutTotal)} used</span><span>&middot;</span><span>{fmt(b.waste)} waste</span><span>&middot;</span><span>{b.efficiency.toFixed(1)}%</span><span>&middot;</span>
                      <span style={{ color: "#059669" }}>{b.assigned.filter(c => c.disposition === "pack" && !c.recut).length} pack</span>
                      <span style={{ color: "#D97706" }}>{b.assigned.filter(c => c.disposition === "touchup" && !c.recut).length} TU</span>
                      {b.assigned.some(c => c.recut) && <span style={{ color: "#DC2626" }}>{b.assigned.filter(c => c.recut).length} recut</span>}
                    </div>
                    {[...b.assigned].sort((a, c) => a.pos - c.pos).map(c => (
                      <div key={c.id} style={{ display: "flex", alignItems: "center", gap: 6, padding: "3px 4px", fontSize: 11, borderTop: "1px solid #F3F4F6", opacity: c.recut ? 0.5 : 1 }}>
                        <span style={{ display: "inline-block", width: 8, height: 8, borderRadius: 2, backgroundColor: colorFor(cutLabel(c)), flexShrink: 0 }} />
                        <span style={{ flex: "1 1 auto", textDecoration: c.recut ? "line-through" : "none" }}>{cutLabel(c)}</span>
                        <span style={{ fontFamily: "monospace", color: "#6B7280", flexShrink: 0 }}>{fmt(c.length)}</span>
                        {!c.recut ? (
                          <React.Fragment>
                            <button onClick={() => flipCompletedDisp(bIdx, c.id)} style={{ border: "none", background: "none", cursor: "pointer", fontSize: 10, fontWeight: 600, padding: "2px 8px", borderRadius: 3, color: c.disposition === "pack" ? "#059669" : "#D97706", backgroundColor: c.disposition === "pack" ? "#D1FAE5" : "#FEF3C7" }}>
                              {c.disposition === "pack" ? "Pack" : "TU"}
                            </button>
                            {c.disposition === "touchup" && <button onClick={() => openRecutPanel(bIdx, c.id)} style={{ border: "none", background: "none", cursor: "pointer", fontSize: 10, fontWeight: 600, padding: "2px 8px", borderRadius: 3, color: "#DC2626", backgroundColor: "#FEE2E2" }}>Recut</button>}
                          </React.Fragment>
                        ) : (
                          <span style={{ fontSize: 10, fontWeight: 600, color: "#DC2626", padding: "2px 8px", borderRadius: 3, backgroundColor: "#FEE2E2" }}>RECUT{c.recutNewLength ? " \u2192 " + fmt(c.recutNewLength) : ""}{c.recutTakt ? " \u00b7 " + c.recutTakt.toFixed(2) + " min" : ""}</span>
                        )}
                      </div>
                    ))}
                  </div>
                ))}
              </div>
            )}
          </React.Fragment>
        )}

        {/* ═══ DONE ═══ */}
        {phase === "done" && (() => {
          const allCuts = completedBeams.flatMap(b => b.assigned);
          const tuCount = allCuts.filter(c => c.disposition === "touchup").length;
          const totalCut = completedBeams.reduce((s, b) => s + b.cutTotal, 0);
          const totalDmgR = completedBeams.reduce((s, b) => s + (b.damageRelatedWaste || 0), 0);
          const totalDmgZ = completedBeams.reduce((s, b) => s + b.dmgTotal, 0);
          const totalStock = completedBeams.length * stock;
          const adjEff = (totalStock - totalDmgZ) > 0 ? (totalCut / (totalStock - totalDmgZ) * 100) : 0;
          const flippedCount = allCuts.filter(c => c.flippedToTU).length;
          return (
            <React.Fragment>
              <div style={{ ...card, background: "linear-gradient(135deg,#D1FAE5 0%,#A7F3D0 100%)", border: "1px solid #6EE7B7" }}>
                <h2 style={{ margin: "0 0 6px", fontSize: 18, fontWeight: 700, color: "#065F46" }}>All Cuts Complete</h2>
                <p style={{ fontSize: 14, color: "#047857", margin: 0 }}>{allCuts.length} parts across {completedBeams.length} beam{completedBeams.length !== 1 ? "s" : ""} &mdash; {matColor} {stockType}</p>
                {leadName && <p style={{ fontSize: 12, color: "#065F46", margin: "4px 0 0" }}>Lead: {leadName}{operatorName ? " \u00B7 Opr: " + operatorName : ""}</p>}
              </div>

              <div style={card}>
                <h2 style={{ margin: "0 0 12px", fontSize: 15, fontWeight: 600, color: "#374151" }}>Summary</h2>
                <div style={{ display: "flex", gap: 12, flexWrap: "wrap", marginBottom: 14 }}>
                  <Stat label="Beams" value={completedBeams.length} color="#DBEAFE" />
                  <Stat label="Parts" value={allCuts.length} color="#F3F4F6" />
                  <Stat label="Pack" value={allCuts.length - tuCount} color="#D1FAE5" />
                  <Stat label="Touch Up" value={tuCount} color="#FEF3C7" />
                  <Stat label="TU %" value={(allCuts.length > 0 ? (tuCount / allCuts.length * 100).toFixed(1) : "0") + "%"} color={tuCount / allCuts.length > 0.2 ? "#FEE2E2" : "#D1FAE5"} />
                  {flippedCount > 0 && <Stat label="Missed @ Saw" value={flippedCount} color="#FEE2E2" />}
                </div>
                <div style={{ display: "flex", gap: 12, flexWrap: "wrap", marginBottom: 14 }}>
                  <Stat label="Material Used" value={fmt(totalCut)} color="#D1FAE5" />
                  <Stat label="Opt. Waste" value={fmt(completedBeams.reduce((s, b) => s + b.waste, 0))} color="#FEF3C7" />
                  <Stat label="Dmg Waste" value={fmt(totalDmgR)} color="#FECACA" />
                  <Stat label="Efficiency" value={(totalCut / totalStock * 100).toFixed(1) + "%"} color="#E0E7FF" />
                  <Stat label="Adj Eff" value={adjEff.toFixed(1) + "%"} color="#DBEAFE" />
                </div>
                {dashData && (
                  <div style={{ display: "flex", gap: 12, flexWrap: "wrap" }}>
                    <Stat label="Avg Takt" value={fmtMin(dashData.avgTakt)} color="#DBEAFE" />
                    <Stat label="Best Takt" value={dashData.taktArr.length ? fmtMin(Math.min(...dashData.taktArr.map(t => t.takt))) : "N/A"} color="#D1FAE5" />
                    <Stat label="Slowest" value={dashData.taktArr.length ? fmtMin(Math.max(...dashData.taktArr.map(t => t.takt))) : "N/A"} color="#FEF3C7" />
                    {dashData.recutCount > 0 && <Stat label="Recut Takt" value={fmtMin(dashData.avgRecutTakt)} color="#F3E8FF" />}
                    {dashData.recutCount > 0 && <Stat label="Recut Time" value={fmtMin(dashData.totalRecutTime)} color="#EDE9FE" />}
                  </div>
                )}
              </div>

              {completedBeams.some(b => b.damages.length > 0) && (
                <div style={card}>
                  <h2 style={{ margin: "0 0 12px", fontSize: 15, fontWeight: 600, color: "#374151" }}>Damage Summary</h2>
                  <table style={{ width: "100%", borderCollapse: "collapse", fontSize: 12 }}>
                    <thead><tr style={{ borderBottom: "2px solid #E5E7EB" }}>
                      <th style={{ textAlign: "left", padding: "5px 8px", color: "#6B7280" }}>Beam</th>
                      <th style={{ textAlign: "left", padding: "5px 8px", color: "#6B7280" }}>Bundle</th>
                      <th style={{ textAlign: "left", padding: "5px 8px", color: "#6B7280" }}>Location</th>
                      <th style={{ textAlign: "left", padding: "5px 8px", color: "#6B7280" }}>Type</th>
                      <th style={{ textAlign: "left", padding: "5px 8px", color: "#6B7280" }}>Consult</th>
                      <th style={{ textAlign: "right", padding: "5px 8px", color: "#6B7280" }}>Dmg Waste</th>
                    </tr></thead>
                    <tbody>
                      {completedBeams.filter(b => b.damages.length > 0).map(b => b.damages.map((d, di) => (
                        <tr key={b.id + "-" + d.id} style={{ borderBottom: "1px solid #F3F4F6" }}>
                          {di === 0 && <td style={{ padding: "5px 8px", verticalAlign: "top" }} rowSpan={b.damages.length}>Beam {b.id}</td>}
                          {di === 0 && <td style={{ padding: "5px 8px", verticalAlign: "top" }} rowSpan={b.damages.length}>{b.bundleNumber || "\u2014"}</td>}
                          <td style={{ padding: "5px 8px", fontFamily: "monospace" }}>{fmt(d.start)}&rarr;{fmt(d.end)}</td>
                          <td style={{ padding: "5px 8px" }}>{d.damageType}</td>
                          <td style={{ padding: "5px 8px" }}>{d.consultCalled ? d.consultResult : "No"}</td>
                          {di === 0 && <td style={{ padding: "5px 8px", textAlign: "right", fontWeight: 600, verticalAlign: "top" }} rowSpan={b.damages.length}>{fmt(b.damageRelatedWaste || 0)}</td>}
                        </tr>
                      )))}
                    </tbody>
                  </table>
                </div>
              )}

              <div style={card}>
                <h2 style={{ margin: "0 0 12px", fontSize: 15, fontWeight: 600, color: "#374151" }}>Export Reports</h2>
                <div style={{ display: "flex", gap: 10, flexWrap: "wrap" }}>
                  <button style={{ ...btn("#4F46E5"), padding: "10px 20px" }} onClick={() => exportDamageReport(completedBeams)}>Damage Report (.xlsx)</button>
                  <button style={{ ...btn("#7C3AED"), padding: "10px 20px" }} onClick={() => exportDamageWaste(completedBeams, stock)}>Damage Waste (.xlsx)</button>
                  <button style={{ ...btn("#0891B2"), padding: "10px 20px" }} onClick={() => exportShiftSummary(completedBeams, cuts, stock, sessionStart, leadName, operatorName, matColor, stockType)}>Shift Summary (.xlsx)</button>
                  {sheetsUrl && <button style={{ ...btn("#059669"), padding: "10px 20px" }} onClick={logAllToSheets} disabled={sheetsStatus === "Sending..."}>{sheetsStatus || "Log to Google Sheets"}</button>}
                </div>
                <p style={{ fontSize: 11, color: "#9CA3AF", marginTop: 8 }}>Damage Report: locations &amp; types. Damage Waste: all waste derived from damage per beam. Shift Summary: timestamps, dispositions, takt times, efficiency.</p>
              </div>

              {completedBeams.map((b, bIdx) => (
                <div key={b.id} style={card}>
                  <div style={{ fontSize: 14, fontWeight: 600, marginBottom: 8 }}>Beam {b.id}{b.bundleNumber ? " \u2014 Bndl " + b.bundleNumber : ""} <span style={{ fontWeight: 400, color: "#9CA3AF", fontSize: 11 }}>@ {tsStr(b.completedAt)}</span></div>
                  <BeamDiagram stock={stock} plan={{ assigned: b.assigned }} damages={b.damages} kerf={kerf} isCrown={isCrown} />
                  <table style={{ width: "100%", borderCollapse: "collapse", fontSize: 12, marginTop: 6 }}>
                    <tbody>{[...b.assigned].sort((a, c) => a.pos - c.pos).map(c => (
                      <tr key={c.id} style={{ borderBottom: "1px solid #F3F4F6", backgroundColor: c.recut ? "#FEF2F2" : c.disposition === "touchup" ? "#FFFBEB" : "transparent", opacity: c.recut ? 0.6 : 1 }}>
                        <td style={{ padding: "4px 8px", textDecoration: c.recut ? "line-through" : "none" }}><span style={{ display: "inline-block", width: 8, height: 8, borderRadius: 2, backgroundColor: colorFor(cutLabel(c)), marginRight: 6 }} />{cutLabel(c)}</td>
                        <td style={{ textAlign: "right", padding: "4px 8px", fontFamily: "monospace" }}>{fmt(c.length)}</td>
                        <td style={{ textAlign: "right", padding: "4px 8px", fontFamily: "monospace", color: "#6B7280" }}>at {fmt(c.pos)}</td>
                        <td style={{ textAlign: "right", padding: "4px 8px" }}>
                          {c.recut ? (
                            <span style={{ fontSize: 11, fontWeight: 600, color: "#DC2626", padding: "1px 6px", borderRadius: 3, backgroundColor: "#FEE2E2" }}>Recut{c.recutNewLength ? " \u2192 " + (c.recutNewLabel || "") + " " + fmt(c.recutNewLength) : ""}</span>
                          ) : (
                            <button onClick={() => flipCompletedDisp(bIdx, c.id)} style={{ border: "none", background: "none", cursor: "pointer", fontSize: 11, fontWeight: 600, color: c.disposition === "pack" ? "#059669" : "#D97706", padding: "1px 6px", borderRadius: 3, backgroundColor: c.disposition === "pack" ? "#D1FAE5" : "#FEF3C7" }}>{c.disposition === "pack" ? "Pack" : "Touch Up"}</button>
                          )}
                        </td>
                        <td style={{ textAlign: "right", padding: "4px 4px", width: 50 }}>
                          {!c.recut && c.disposition === "touchup" && (
                            <button onClick={() => openRecutPanel(bIdx, c.id)} style={{ border: "none", background: "none", cursor: "pointer", fontSize: 10, fontWeight: 600, color: "#DC2626", padding: "1px 6px", borderRadius: 3, backgroundColor: "#FEE2E2" }}>Recut</button>
                          )}
                        </td>
                      </tr>
                    ))}</tbody>
                  </table>
                  <div style={{ display: "flex", gap: 8, fontSize: 11, color: "#6B7280", marginTop: 6, flexWrap: "wrap" }}>
                    <span>Waste: {fmt(b.waste)}</span><span>&middot;</span><span>Kerf: {fmt(b.kerfTotal)}</span>
                    {b.dmgTotal > 0 && <React.Fragment><span>&middot;</span><span>Dmg: {fmt(b.dmgTotal)}</span></React.Fragment>}
                    {(b.damageRelatedWaste || 0) > 0 && <React.Fragment><span>&middot;</span><span style={{ color: "#DC2626" }}>Dmg Waste: {fmt(b.damageRelatedWaste)}</span></React.Fragment>}
                    <span>&middot;</span><span>{b.efficiency.toFixed(1)}%</span>
                    {b.assigned.some(c => c.recut) && <React.Fragment><span>&middot;</span><span style={{ color: "#DC2626" }}>{b.assigned.filter(c => c.recut).length} recut</span></React.Fragment>}
                  </div>
                </div>
              ))}
              <button style={{ ...btn("#2563EB"), padding: "10px 28px" }} onClick={() => { setPhase("setup"); setCompletedBeams([]); setDoneIds(new Set()); setCurrentDmg([]); }}>Start New Cutlist</button>
            </React.Fragment>
          );
        })()}
      </div>

      {/* ═══ RECUT PANEL MODAL ═══ */}
      {recutPanel && (() => {
        const segs = buildSegments(recutPanel.stockLen, recutPanel.damages.map(d => ({ start: d.start, end: d.end })));
        const maxSeg = segs.length > 0 ? Math.max(...segs.map(s => s.len)) : recutPanel.stockLen;
        const totalDmg = recutPanel.damages.reduce((s, d) => s + (d.end - d.start), 0);
        const fitting = remaining.filter(c => c.length <= maxSeg - kerf).sort((a, b) => b.length - a.length);
        let previewLen = 0;
        if (recutPanel.useCustom) { const pl = parseLen(recutPanel.customLen); if (!isNaN(pl)) previewLen = pl; }
        else if (recutPanel.selectedCutId) { const c = cuts.find(x => x.id === recutPanel.selectedCutId); if (c) previewLen = c.length; }
        return (
          <div style={{ position: "fixed", inset: 0, backgroundColor: "rgba(0,0,0,0.5)", display: "flex", alignItems: "center", justifyContent: "center", zIndex: 1000, padding: 16 }}>
            <div style={{ backgroundColor: "#fff", borderRadius: 12, padding: 24, maxWidth: 560, width: "100%", maxHeight: "90vh", overflowY: "auto", boxShadow: "0 20px 60px rgba(0,0,0,0.3)" }}>
              <h3 style={{ margin: "0 0 4px", fontSize: 16, fontWeight: 700, color: "#991B1B" }}>Recut: {recutPanel.label}</h3>
              <p style={{ margin: "0 0 12px", fontSize: 13, color: "#6B7280" }}>Original piece: {fmt(recutPanel.stockLen)}</p>

              <BeamDiagram stock={recutPanel.stockLen} plan={null} damages={recutPanel.damages} kerf={0} damageMode={false} isCrown={false} />

              <div style={{ marginBottom: 14 }}>
                <div style={{ fontSize: 13, fontWeight: 600, color: "#374151", marginBottom: 6 }}>Damage on Piece</div>
                {recutPanel.damages.map(d => (
                  <div key={d.id} style={{ display: "flex", alignItems: "center", gap: 6, fontSize: 12, padding: "3px 8px", backgroundColor: "#FEF2F2", border: "1px solid #FECACA", borderRadius: 4, marginBottom: 3 }}>
                    <span style={{ fontWeight: 600, color: "#991B1B" }}>{fmt(d.start)} &rarr; {fmt(d.end)} ({fmt(d.end - d.start)})</span>
                    <span style={{ color: "#6B7280" }}>{d.damageType}</span>
                    {d.fromBeam && <span style={{ fontSize: 10, color: "#9CA3AF" }}>from beam</span>}
                    <button onClick={() => setRecutPanel(p => ({ ...p, damages: p.damages.filter(x => x.id !== d.id) }))} style={{ border: "none", background: "none", color: "#EF4444", cursor: "pointer", fontSize: 14, marginLeft: "auto" }}>&times;</button>
                  </div>
                ))}
                <div style={{ display: "flex", gap: 6, alignItems: "flex-end", marginTop: 6 }}>
                  <div style={{ flex: "0 0 70px" }}><label style={lbl}>Start</label><input style={inp} value={recutPanel.dmgStart} onChange={e => setRecutPanel(p => ({ ...p, dmgStart: e.target.value }))} placeholder="0" /></div>
                  <div style={{ flex: "0 0 70px" }}><label style={lbl}>End</label><input style={inp} value={recutPanel.dmgEnd} onChange={e => setRecutPanel(p => ({ ...p, dmgEnd: e.target.value }))} placeholder="12" /></div>
                  <div style={{ flex: "1 1 120px" }}><label style={lbl}>Type</label><select style={sel} value={recutPanel.dmgType} onChange={e => setRecutPanel(p => ({ ...p, dmgType: e.target.value }))}>{DAMAGE_TYPES.map(t => <option key={t}>{t}</option>)}</select></div>
                  <button style={{ ...btn("#DC2626"), padding: "7px 12px" }} onClick={() => {
                    const s = parseFloat(recutPanel.dmgStart), e = parseFloat(recutPanel.dmgEnd);
                    if (isNaN(s) || isNaN(e) || s >= e || s < 0 || e > recutPanel.stockLen) return;
                    setRecutPanel(p => ({ ...p, damages: [...p.damages, { start: s, end: e, id: Date.now(), damageType: p.dmgType, fromBeam: false }], dmgStart: "", dmgEnd: "" }));
                  }}>+ Dmg</button>
                </div>
                {totalDmg > 0 && <p style={{ fontSize: 11, color: "#6B7280", marginTop: 6 }}>Usable: {fmt(recutPanel.stockLen - totalDmg)} | Longest segment: {fmt(maxSeg)}</p>}
              </div>

              <div style={{ marginBottom: 14 }}>
                <div style={{ fontSize: 13, fontWeight: 600, color: "#374151", marginBottom: 8 }}>Cut To</div>
                {fitting.length > 0 && (
                  <div style={{ marginBottom: 10 }}>
                    <label style={{ display: "flex", alignItems: "center", gap: 6, fontSize: 13, marginBottom: 6, cursor: "pointer" }}>
                      <input type="radio" checked={!recutPanel.useCustom} onChange={() => setRecutPanel(p => ({ ...p, useCustom: false }))} />
                      From Cut List ({fitting.length} fit)
                    </label>
                    {!recutPanel.useCustom && (
                      <select style={{ ...sel, marginLeft: 22, maxWidth: 360 }} value={recutPanel.selectedCutId || ""} onChange={e => setRecutPanel(p => ({ ...p, selectedCutId: parseInt(e.target.value) || null }))}>
                        <option value="">Select a cut...</option>
                        {fitting.map(c => <option key={c.id} value={c.id}>{cutLabel(c)} — {fmt(c.length)}</option>)}
                      </select>
                    )}
                  </div>
                )}
                <label style={{ display: "flex", alignItems: "center", gap: 6, fontSize: 13, marginBottom: 6, cursor: "pointer" }}>
                  <input type="radio" checked={recutPanel.useCustom || fitting.length === 0} onChange={() => setRecutPanel(p => ({ ...p, useCustom: true }))} />
                  Custom Size
                </label>
                {(recutPanel.useCustom || fitting.length === 0) && (
                  <div style={{ display: "flex", gap: 6, marginLeft: 22 }}>
                    <div style={{ flex: "1 1 120px" }}><label style={lbl}>Label (optional)</label><input style={inp} value={recutPanel.customLabel} onChange={e => setRecutPanel(p => ({ ...p, customLabel: e.target.value }))} placeholder="e.g. Short Beam" /></div>
                    <div style={{ flex: "0 0 90px" }}><label style={lbl}>Length</label><input style={inp} value={recutPanel.customLen} onChange={e => setRecutPanel(p => ({ ...p, customLen: e.target.value }))} placeholder='84' /></div>
                  </div>
                )}
                {fitting.length === 0 && !recutPanel.useCustom && (
                  <p style={{ fontSize: 12, color: "#D97706", marginTop: 4 }}>No cuts from the list fit. Use custom size or adjust damage.</p>
                )}
              </div>

              {previewLen > 0 && (
                <div style={{ fontSize: 12, padding: "8px 12px", backgroundColor: "#F3F4F6", borderRadius: 6, marginBottom: 14 }}>
                  <span style={{ fontWeight: 600 }}>Salvage:</span> {fmt(previewLen)} &nbsp;|&nbsp; <span style={{ color: "#DC2626", fontWeight: 600 }}>Scrap:</span> {fmt(recutPanel.stockLen - previewLen)}
                </div>
              )}

              <div style={{ display: "flex", gap: 8, justifyContent: "flex-end" }}>
                <button style={btn("#E5E7EB", "#374151")} onClick={() => setRecutPanel(null)}>Cancel</button>
                <button style={btn("#DC2626")} onClick={confirmRecut} disabled={!recutPanel.useCustom && !recutPanel.selectedCutId && fitting.length > 0}>Confirm Recut</button>
              </div>
            </div>
          </div>
        );
      })()}
    </div>
  );
}

ReactDOM.createRoot(document.getElementById("root")).render(<CutlistOptimizer />);
</script>
</body>
</html>
